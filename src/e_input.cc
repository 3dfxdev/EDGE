//----------------------------------------------------------------------------
//  EDGE Input handling
//----------------------------------------------------------------------------
// 
//  Copyright (c) 1999-2009  The EDGE Team.
// 
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//----------------------------------------------------------------------------
//
//  Based on the DOOM source code, released by Id Software under the
//  following copyright:
//
//    Copyright (C) 1993-1996 by id Software, Inc.
//
//----------------------------------------------------------------------------
//
// -MH- 1998/07/02 Added key_flyup and key_flydown variables (no logic yet)
// -MH- 1998/08/18 Flyup and flydown logic
//

#include "i_defs.h"

#include "ddf/level.h"

#include "g_state.h"
#include "e_input.h"
#include "e_main.h"
#include "g_game.h"
#include "hu_stuff.h"
#include "m_math.h"
#include "m_misc.h"
#include "r_misc.h"
#include "z_zone.h"


extern bool CON_Responder(event_t *ev);
extern bool   M_Responder(event_t *ev);
extern bool   G_Responder(event_t *ev);

extern int I_JoyGetAxis(int n);


//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
#define MAXEVENTS  128

static event_t events[MAXEVENTS];
static int eventhead;
static int eventtail;

//
// controls (have defaults) 
// 
key_binding_c k_forward;
key_binding_c k_back;
key_binding_c k_left;
key_binding_c k_right;

key_binding_c k_turnright;
key_binding_c k_turnleft;
key_binding_c k_lookup;
key_binding_c k_lookdown;
key_binding_c k_lookcenter;

// -ES- 1999/03/28 Zoom Key
key_binding_c k_zoom;

key_binding_c k_fire;
key_binding_c k_secondatk;
key_binding_c k_use;
key_binding_c k_strafe;
key_binding_c k_speed;
key_binding_c k_autorun;
key_binding_c k_turn180;
key_binding_c k_mlook;
key_binding_c k_reload;

// -MH- 1998/07/10 Flying keys
key_binding_c k_up;
key_binding_c k_down;

key_binding_c k_weapons[10]; // -AJA- 2009/06/20.
key_binding_c k_nextweapon;
key_binding_c k_prevweapon;

#define MAXPLMOVE  (forwardmove[1])

static int forwardmove[2] = {0x19, 0x32};
static int sidemove[2]    = {0x18, 0x28};
static int upwardmove[2]  = {0x19, 0x32};  // -MH- 1998/08/18 Up/Down movement
static int angleturn[3]   = {640, 1280, 320};  // + slow turn 

#define SLOWTURNTICS    6

#define GK_DOWN  0x01
#define GK_UP    0x02

byte gamekeydown[NUMKEYS];

static int turnheld;   // for accelerative turning 
static int mlookheld;  // for accelerative mlooking 

// toggled by autorun button.
cvar_c in_autorun;
cvar_c in_stageturn;
cvar_c in_shiftlook;

cvar_c debug_mouse;
cvar_c debug_joyaxis;

//-------------------------------------------
// -KM-  1998/09/01 Analogue binding
// -ACB- 1998/09/06 Two-stage turning switch
//

cvar_c mouse_x_axis, mouse_x_sens;
cvar_c mouse_y_axis, mouse_y_sens;

cvar_c mouse_filter;  // FIXME: nyi
cvar_c mouse_accel;  // FIXME: not implemented yet


// The first one is ignored (AXIS_DISABLE)
static float analogue[6] = {0, 0, 0, 0, 0, 0};

static float MergeMouseBall(int axis)
{
	return analogue[axis] / 100.0;

#if 0  // TODO
	float result = 0;

	if (mouse_data.x_axis.d == axis)
		result += mouse_data.x_value * mouse_data.x_sens.f;

	if (mouse_data.y_axis.d == axis)
		result += mouse_data.y_value * mouse_data.y_sens.f;

	if (ball_data.x_axis.d == axis)
		result += ball_data.x_value * ball_data.x_sens.f;

	if (ball_data.y_axis.d == axis)
		result += ball_data.y_value * ball_data.y_sens.f;

	return result;
#endif
}


#if 0  // UNUSED ???
static int CmdChecksum(ticcmd_t * cmd)
{
	int i;
	int sum = 0;

	for (i = 0; i < (int)sizeof(ticcmd_t) / 4 - 1; i++)
		sum += ((int *)cmd)[i];

	return sum;
}
#endif


#define NUM_JAXIS_GROUP  9

jaxis_group_c joyaxis1, joyaxis2, joyaxis3;
jaxis_group_c joyaxis4, joyaxis5, joyaxis6;
jaxis_group_c joyaxis7, joyaxis8, joyaxis9;

static jaxis_group_c * joy_axis_groups[NUM_JAXIS_GROUP] =
{
	&joyaxis1, &joyaxis2, &joyaxis3,
	&joyaxis4, &joyaxis5, &joyaxis6,
	&joyaxis7, &joyaxis8, &joyaxis9
};


jaxis_group_c::jaxis_group_c() : axis(), sens(), dead(), peak(),
                                 tune(), filter(), value(0.0f)
{
	for (int k = 0; k < JAXIS_HISTORY; k++)
		history[k] = 0;
}

jaxis_group_c::~jaxis_group_c()
{ }

// this must be called as regularly as possible, the actual
// frequency is less important (35 times per sec is OK).
void jaxis_group_c::NewTic(int v)
{
	SYS_ASSERT(abs(v) <= 32768);

	for (int k = JAXIS_HISTORY-1; k > 0; k--)
		history[k] = history[k-1];

	history[0] = v;

	int raw = 0;
	int filt_num = 1 + CLAMP(0, filter.d, JAXIS_HISTORY-1);

	for (int i = 0; i < filt_num; i++)
		raw += history[i];

///I_Printf("raw:%+05d filt:%+05d num:%d  hist:%+05d %+05d +%05d %+05d\n",
//		 v, raw / filt_num, filt_num,
//		 history[1], history[2], history[3], history[4]);
	SetFromRaw(raw / filt_num);
}

void jaxis_group_c::SetFromRaw(int raw)
{
	SYS_ASSERT(abs(raw) <= 32768);

	float v = raw / 32768.0f;
	
	if (fabs(v) < dead.f)
	{
		value = 0.0f;
		return;
	}

	if (fabs(v) >= peak.f)
	{
		value = (v < 0) ? -1.0f : +1.0f;
		return;
	}

	SYS_ASSERT(peak.f > dead.f);

	float t = CLAMP(0.2f, tune.f, 5.0f);

	if (v >= 0)
	{
		v = (v - dead.f) / (peak.f - dead.f);
		value = pow(v, 1.0f / t);
	}
	else
	{
		v = (-v - dead.f) / (peak.f - dead.f);
		value = - pow(v, 1.0f / t);
	}
}


static void UpdateJoyAxes(void)
{
	for (int ja = 0; ja < NUM_JAXIS_GROUP; ja++)
	{
		jaxis_group_c *jg = joy_axis_groups[ja];
	
		int raw = I_JoyGetAxis(ja);

		jg->NewTic(raw);

		if (debug_joyaxis.d == ja+1)
		{
			I_Printf("Axis%d : raw %+05d --> %+7.3f\n", ja+1, raw, jg->value * jg->sens.f);
		}
	}
}

static float MergeKeyJoy(int axis, key_binding_c *pos, key_binding_c *neg)
{
	float result = 0.0f;

	//let movement keys cancel each other out
	if (pos && pos->IsPressed())
		result += 1.0f;

	if (neg && neg->IsPressed())
		result -= 1.0f;
	
	for (int ja = 0; ja < NUM_JAXIS_GROUP; ja++)
	{
		jaxis_group_c *jg = joy_axis_groups[ja];

		if (abs(jg->axis.d) != axis)
			continue;

		result += jg->value * jg->sens.f / 10.0;
	}

	return result;
}


//
// Builds a ticcmd from all of the available inputs
//
// -ACB- 1998/07/02 Added Vertical angle checking for mlook.
// -ACB- 1998/07/10 Reformatted: I can read the code! :)
//
void E_BuildTiccmd(ticcmd_t * cmd)
{
	UpdateJoyAxes();

	Z_Clear(cmd, ticcmd_t, 1);

	bool strafe = k_strafe.IsPressed();
	int  speed  = k_speed.IsPressed() ? 1 : 0;

	if (in_autorun.d)
		speed = !speed;

	int m_speed = in_shiftlook.d ? speed : 0;

	// Turning
	if (! strafe)
	{
		float s = MergeKeyJoy(AXIS_TURN,  &k_turnright, &k_turnleft);
		float t = MergeMouseBall(AXIS_TURN);
		float turn = 0;

		if (fabs(s) > 0.20f)
			turnheld++;
		else
			turnheld = 0;

		// slow turn ?
		int t_speed = speed;
		if (in_stageturn.d && turnheld < SLOWTURNTICS)
			t_speed = 2;

		turn -= s * angleturn[t_speed];
		turn -= t * angleturn[m_speed];

		cmd->angleturn = I_ROUND(turn);
	}

	// MLook
	{
		float s = MergeKeyJoy(AXIS_MLOOK, &k_lookup,    &k_lookdown);
		float t = MergeMouseBall(AXIS_MLOOK);
		float mlook = 0;

		if (fabs(s) > 0.20f)
			mlookheld++;
		else
			mlookheld = 0;

		// slow turn ?
		int u_speed = speed;
		if (in_stageturn.d && mlookheld < SLOWTURNTICS)
			u_speed = 2;

		mlook += s * angleturn[u_speed] / 1.5f;
		mlook += t * angleturn[m_speed] / 1.5f;

		cmd->mlookturn = I_ROUND(mlook);
	}

	// Forward
	{
		float s = MergeKeyJoy(AXIS_FORWARD, &k_forward, &k_back);
		float t = MergeMouseBall(AXIS_FORWARD);
		float forward = 0;

		forward += s * forwardmove[speed];
		forward += t * forwardmove[speed];

		forward = CLAMP(-MAXPLMOVE, forward, MAXPLMOVE);

		cmd->forwardmove = I_ROUND(forward);
	}

	// Sideways
	{
		float s = MergeKeyJoy(AXIS_STRAFE, &k_right, &k_left);
		float t = MergeMouseBall(AXIS_STRAFE);
		float side = 0;

		side += s * sidemove[speed];
		side += t * sidemove[speed];

		if (strafe)
		{
			float s = MergeKeyJoy(AXIS_TURN, &k_turnright, &k_turnleft);
			float t = MergeMouseBall(AXIS_TURN);

			side += s * sidemove[speed];
			side += t * sidemove[speed];
		}

		side = CLAMP(-MAXPLMOVE, side, MAXPLMOVE);

		cmd->sidemove = I_ROUND(side);
	}

	// Upwards  -MH- 1998/08/18 Fly up
	{
		float s = MergeKeyJoy(AXIS_FLY, &k_up, &k_down);
		float t = MergeMouseBall(AXIS_FLY);
		float upward = 0;

		upward += s * upwardmove[speed];
		upward += t * upwardmove[speed];

		upward = CLAMP(-MAXPLMOVE, upward, MAXPLMOVE);

		cmd->upwardmove = I_ROUND(upward);
	}

	// Buttons...

	if (k_fire.IsPressed())
		cmd->buttons |= BT_ATTACK;

	if (k_secondatk.IsPressed())
		cmd->extbuttons |= EBT_SECONDATK;

	if (k_use.IsPressed())
		cmd->buttons |= BT_USE;

	if (k_reload.IsPressed())
		cmd->extbuttons |= EBT_RELOAD;

	// -ACB- 1998/07/02 Use CENTER flag to center the vertical look.
	if (k_lookcenter.IsPressed())
		cmd->extbuttons |= EBT_CENTER;

	// -KM- 1998/11/25 Weapon change key
	for (int w = 0; w < 10; w++)
	{
		if (k_weapons[w].IsPressed())
		{
			cmd->buttons |= BT_CHANGE;
			cmd->buttons |= w << BT_WEAPONSHIFT;
			break;
		}
	}

	if (k_nextweapon.WasJustPressed())
	{
		cmd->buttons |= BT_CHANGE;
		cmd->buttons |= (BT_NEXT_WEAPON << BT_WEAPONSHIFT);
	}
	else if (k_prevweapon.WasJustPressed())
	{
		cmd->buttons |= BT_CHANGE;
		cmd->buttons |= (BT_PREV_WEAPON << BT_WEAPONSHIFT);
	}

	// You have to release the 180 deg turn key before you can press it again
	if (k_turn180.WasJustPressed())
		cmd->angleturn ^= (s16_t)0x8000;

	// -ES- 1999/03/28 Zoom Key
	if (k_zoom.WasJustPressed())
		cmd->extbuttons |= EBT_ZOOM;

	// -AJA- 2000/04/14: Autorun toggle
	if (k_autorun.WasJustPressed())
		in_autorun = in_autorun.d ? 0 : 1;

///??	cmd->chatchar = HU_DequeueChatChar();

	for (int k = 0; k < 6; k++)
		analogue[k] = 0;
}

//
// Get info needed to make ticcmd_ts for the players.
// 
bool INP_Responder(event_t * ev)
{
	switch (ev->type)
	{
		case ev_keydown:
			if (ev->value.key.sym != KEYD_IGNORE &&
			    ev->value.key.sym < NUMKEYS)
			{
				gamekeydown[ev->value.key.sym] &= ~GK_UP;
				gamekeydown[ev->value.key.sym] |=  GK_DOWN;
			}

			// eat key down events 
			return true;

		case ev_keyup:
			if (ev->value.key.sym != KEYD_IGNORE &&
			    ev->value.key.sym < NUMKEYS)
			{
				gamekeydown[ev->value.key.sym] |= GK_UP;
			}

			// always let key up events filter down 
			return false;

			// -KM- 1998/09/01 Change mouse/joystick to analogue
		case ev_mouse:
		{
			int x_axis = CLAMP(0, mouse_x_axis.d, AXIS_FLY);
			int y_axis = CLAMP(0, mouse_y_axis.d, AXIS_FLY);

			float dx = ev->value.mouse.dx;
			float dy = ev->value.mouse.dy;

			// mouse Y usually needs inverting, but this can be
			// changed by using a negative mouse_y.sens
			dy = -dy;

			dx *= mouse_x_sens.f;
			dy *= mouse_y_sens.f;

			if (debug_mouse.d)
				I_Printf("Mouse %+04d %+04d --> %+7.2f %+7.2f\n",
				         ev->value.mouse.dx, ev->value.mouse.dy, dx, dy);

			// -AJA- 1999/07/27: Mlook key like quake's.
			if (k_mlook.IsPressed())
			{
				analogue[AXIS_TURN]  += dx;
				analogue[AXIS_MLOOK] += dy;
			}
			else
			{
				analogue[x_axis] += dx;
				analogue[y_axis] += dy;
			}

			return true;  // eat events
		}

		default:
			break;
	}

	return false;
}

//
// Sets the turbo scale (100 is normal)
//
void E_SetTurboScale(int scale)
{
	const int origforwardmove[2] = {0x19, 0x32};
	const int origsidemove[2]    = {0x18, 0x28};
	const int origupwardmove[2]  = {0x19, 0x32};

	forwardmove[0] = origforwardmove[0] * scale / 100;
	forwardmove[1] = origforwardmove[1] * scale / 100;
	sidemove[0]    = origsidemove[0] * scale / 100;
	sidemove[1]    = origsidemove[1] * scale / 100;
	upwardmove[0]  = origupwardmove[0] * scale / 100;
	upwardmove[1]  = origupwardmove[1] * scale / 100;
}


void E_ClearInput(void)
{
	Z_Clear(gamekeydown, byte, NUMKEYS);

	for (int k = 0; k < 6; k++)
		analogue[k] = 0;

	turnheld  = 0;
	mlookheld = 0;
}

//
// Finds all keys in the gamekeydown[] array which have been released
// and clears them.  The value is NOT cleared by INP_Responder() since
// that prevents very fast presses (also the mousewheel) from being
// down long enough to be noticed by E_BuildTiccmd().
//
// -AJA- 2005/02/17: added this.
//
void E_UpdateKeyState(void)
{
	for (int k = 0; k < NUMKEYS; k++)
		if (gamekeydown[k] & GK_UP)
			gamekeydown[k] = 0;
}

//
// Generate events which should release all current keys.
//
void E_ReleaseAllKeys(void)
{
	int i;
	for (i = 0; i < NUMKEYS; i++)
	{
		if (gamekeydown[i] & GK_DOWN)
		{
			event_t ev;
			
			ev.type = ev_keyup;
			ev.value.key.sym = i;
			ev.value.key.unicode = 0;
			
			E_PostEvent(&ev);
		}
	}
}

//
// Called by the I/O functions when input is detected
//
void E_PostEvent(event_t * ev)
{
	events[eventhead] = *ev;
	eventhead = (eventhead + 1) % MAXEVENTS;

#ifdef DEBUG_KEY_EV  //!!!!
if (ev->type == ev_keydown || ev->type == ev_keyup)
{
	L_WriteDebug("EVENT @ %08x %d %s\n",
		I_ReadMicroSeconds()/1000,
		ev->value.key.sym,
		(ev->type == ev_keyup) ? "DOWN" : "up");
}
#endif
}

//
// Send all the events of the given timestamp down the responder chain
//
void E_ProcessEvents(void)
{
	I_ControlGetEvents();

	event_t *ev;

	for (; eventtail != eventhead; eventtail = (eventtail + 1) % MAXEVENTS)
	{
		ev = &events[eventtail];

		if (chat_on && HU_Responder(ev))
			continue;  // let chat eat the event first of all

		if (CON_Responder(ev))
			continue;  // GUI ate the event

		if (M_Responder(ev))
			continue;  // menu ate the event

		G_Responder(ev);  // let game eat it, nobody else wanted it
	}
}


//--- editor settings ---
// vi:ts=4:sw=4:noexpandtab
